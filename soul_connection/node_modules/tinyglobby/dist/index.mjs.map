{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import path, { posix } from 'node:path';\nimport { type Options as FdirOptions, fdir } from 'fdir';\nimport picomatch from 'picomatch';\n\nexport interface GlobOptions {\n  absolute?: boolean;\n  cwd?: string;\n  patterns?: string[];\n  ignore?: string[];\n  dot?: boolean;\n  deep?: number;\n  expandDirectories?: boolean;\n  onlyDirectories?: boolean;\n  onlyFiles?: boolean;\n}\n\ninterface InternalProperties {\n  root: string;\n  commonPath: string[] | null;\n  depthOffset: number;\n}\n\nfunction normalizePattern(\n  pattern: string,\n  expandDirectories: boolean,\n  cwd: string,\n  properties: InternalProperties,\n  isIgnore: boolean\n) {\n  let result: string = pattern;\n  if (pattern.endsWith('/')) {\n    result = pattern.slice(0, -1);\n  }\n  // using a directory as entry should match all files inside it\n  if (!result.endsWith('*') && expandDirectories) {\n    result += '/**';\n  }\n\n  if (result.startsWith(cwd)) {\n    return posix.relative(cwd, result);\n  }\n\n  if (result.startsWith('./')) {\n    result = result.slice(2);\n  }\n\n  const parentDirectoryMatch = /^(\\/?\\.\\.)+/.exec(result);\n  if (parentDirectoryMatch?.[0]) {\n    const potentialRoot = posix.join(cwd, parentDirectoryMatch[0]);\n    if (properties.root.length > potentialRoot.length) {\n      properties.root = potentialRoot;\n      properties.depthOffset = -(parentDirectoryMatch[0].length + 1) / 3;\n    }\n  } else if (!isIgnore && properties.depthOffset >= 0) {\n    const current = result.split('/');\n    properties.commonPath ??= current;\n\n    const newCommonPath = [];\n\n    for (let i = 0; i < Math.min(properties.commonPath.length, current.length); i++) {\n      const part = current[i];\n      if (properties.commonPath[i] === part && !/[\\!\\*\\{\\}\\(\\)]/.test(part)) {\n        newCommonPath.push(part);\n      } else {\n        break;\n      }\n    }\n\n    newCommonPath.pop();\n\n    properties.depthOffset = newCommonPath.length;\n    properties.commonPath = newCommonPath;\n\n    properties.root = newCommonPath.length > 0 ? `${cwd}/${newCommonPath.join('/')}` : cwd;\n  }\n\n  return result;\n}\n\nfunction processPatterns(\n  { patterns, ignore = [], expandDirectories = true }: GlobOptions,\n  cwd: string,\n  properties: InternalProperties\n) {\n  const matchPatterns: string[] = [];\n  const ignorePatterns: string[] = ignore.map(p => normalizePattern(p, expandDirectories, cwd, properties, true));\n\n  if (!patterns) {\n    return { match: ['**/*'], ignore: ignorePatterns };\n  }\n\n  for (let pattern of patterns) {\n    pattern = normalizePattern(pattern, expandDirectories, cwd, properties, false);\n    if (pattern.startsWith('!') && pattern[1] !== '(') {\n      ignorePatterns.push(pattern.slice(1));\n    } else {\n      matchPatterns.push(pattern);\n    }\n  }\n\n  return { match: matchPatterns, ignore: ignorePatterns };\n}\n\n// TODO: this is slow, find a better way to do this\nfunction getRelativePath(path: string, cwd: string, root: string) {\n  return posix.relative(cwd, `${root}/${path}`);\n}\n\nfunction processPath(path: string, cwd: string, root: string, isDirectory: boolean, absolute?: boolean) {\n  const relativePath = absolute ? path.slice(root.length + 1) : path;\n  //if (absolute) console.log({ path, cwd, root, relativePath });\n  if (root === cwd) {\n    return isDirectory ? relativePath.slice(0, -1) : relativePath;\n  }\n\n  return getRelativePath(relativePath, cwd, root);\n}\n\nfunction crawl(options: GlobOptions, cwd: string, sync: false): Promise<string[]>;\nfunction crawl(options: GlobOptions, cwd: string, sync: true): string[];\nfunction crawl(options: GlobOptions, cwd: string, sync: boolean) {\n  const properties = {\n    root: cwd,\n    commonPath: null,\n    depthOffset: 0\n  };\n\n  const processed = processPatterns(options, cwd, properties);\n\n  const matcher = picomatch(processed.match, {\n    dot: options.dot,\n    ignore: processed.ignore\n  });\n\n  const exclude = picomatch(processed.ignore, {\n    dot: options.dot\n  });\n\n  const fdirOptions: Partial<FdirOptions> = {\n    // use relative paths in the matcher\n    filters: [(p, isDirectory) => matcher(processPath(p, cwd, properties.root, isDirectory, options.absolute))],\n    exclude: (_, p) => exclude(processPath(p, cwd, properties.root, true, true)),\n    pathSeparator: '/',\n    relativePaths: true\n  };\n\n  if (options.deep) {\n    fdirOptions.maxDepth = Math.round(options.deep - properties.depthOffset);\n  }\n\n  if (options.absolute) {\n    fdirOptions.relativePaths = false;\n    fdirOptions.resolvePaths = true;\n    fdirOptions.includeBasePath = true;\n  }\n\n  if (options.onlyDirectories) {\n    fdirOptions.excludeFiles = true;\n    fdirOptions.includeDirs = true;\n  } else if (options.onlyFiles === false) {\n    fdirOptions.includeDirs = true;\n  }\n\n  const api = new fdir(fdirOptions).crawl(properties.root);\n\n  if (cwd === properties.root || options.absolute) {\n    return sync ? api.sync() : api.withPromise();\n  }\n\n  return sync\n    ? api.sync().map(p => getRelativePath(p, cwd, properties.root) + (!p || p.endsWith('/') ? '/' : ''))\n    : api\n        .withPromise()\n        .then(paths => paths.map(p => getRelativePath(p, cwd, properties.root) + (!p || p.endsWith('/') ? '/' : '')));\n}\n\nexport function glob(patterns: string[], options?: Omit<GlobOptions, 'patterns'>): Promise<string[]>;\nexport function glob(options: GlobOptions): Promise<string[]>;\nexport async function glob(patternsOrOptions: string[] | GlobOptions, options?: GlobOptions): Promise<string[]> {\n  if (patternsOrOptions && options?.patterns) {\n    throw new Error('Cannot pass patterns as both an argument and an option');\n  }\n\n  const opts = Array.isArray(patternsOrOptions) ? { ...options, patterns: patternsOrOptions } : patternsOrOptions;\n  const cwd = opts.cwd ? path.resolve(opts.cwd).replace(/\\\\/g, '/') : process.cwd().replace(/\\\\/g, '/');\n\n  return crawl(opts, cwd, false);\n}\n\nexport function globSync(patterns: string[], options?: Omit<GlobOptions, 'patterns'>): string[];\nexport function globSync(options: GlobOptions): string[];\nexport function globSync(patternsOrOptions: string[] | GlobOptions, options?: GlobOptions): string[] {\n  if (patternsOrOptions && options?.patterns) {\n    throw new Error('Cannot pass patterns as both an argument and an option');\n  }\n\n  const opts = Array.isArray(patternsOrOptions) ? { ...options, patterns: patternsOrOptions } : patternsOrOptions;\n  const cwd = opts.cwd ? path.resolve(opts.cwd).replace(/\\\\/g, '/') : process.cwd().replace(/\\\\/g, '/');\n\n  return crawl(opts, cwd, true);\n}\n"],"mappings":";AAAA,OAAO,QAAQ,aAAa;AAC5B,SAAsC,YAAY;AAClD,OAAO,eAAe;AAoBtB,SAAS,iBACP,SACA,mBACA,KACA,YACA,UACA;AA5BF;AA6BE,MAAI,SAAiB;AACrB,MAAI,QAAQ,SAAS,GAAG,GAAG;AACzB,aAAS,QAAQ,MAAM,GAAG,EAAE;AAAA,EAC9B;AAEA,MAAI,CAAC,OAAO,SAAS,GAAG,KAAK,mBAAmB;AAC9C,cAAU;AAAA,EACZ;AAEA,MAAI,OAAO,WAAW,GAAG,GAAG;AAC1B,WAAO,MAAM,SAAS,KAAK,MAAM;AAAA,EACnC;AAEA,MAAI,OAAO,WAAW,IAAI,GAAG;AAC3B,aAAS,OAAO,MAAM,CAAC;AAAA,EACzB;AAEA,QAAM,uBAAuB,cAAc,KAAK,MAAM;AACtD,MAAI,6DAAuB,IAAI;AAC7B,UAAM,gBAAgB,MAAM,KAAK,KAAK,qBAAqB,CAAC,CAAC;AAC7D,QAAI,WAAW,KAAK,SAAS,cAAc,QAAQ;AACjD,iBAAW,OAAO;AAClB,iBAAW,cAAc,EAAE,qBAAqB,CAAC,EAAE,SAAS,KAAK;AAAA,IACnE;AAAA,EACF,WAAW,CAAC,YAAY,WAAW,eAAe,GAAG;AACnD,UAAM,UAAU,OAAO,MAAM,GAAG;AAChC,qBAAW,eAAX,uBAAW,aAAe;AAE1B,UAAM,gBAAgB,CAAC;AAEvB,aAAS,IAAI,GAAG,IAAI,KAAK,IAAI,WAAW,WAAW,QAAQ,QAAQ,MAAM,GAAG,KAAK;AAC/E,YAAM,OAAO,QAAQ,CAAC;AACtB,UAAI,WAAW,WAAW,CAAC,MAAM,QAAQ,CAAC,iBAAiB,KAAK,IAAI,GAAG;AACrE,sBAAc,KAAK,IAAI;AAAA,MACzB,OAAO;AACL;AAAA,MACF;AAAA,IACF;AAEA,kBAAc,IAAI;AAElB,eAAW,cAAc,cAAc;AACvC,eAAW,aAAa;AAExB,eAAW,OAAO,cAAc,SAAS,IAAI,GAAG,GAAG,IAAI,cAAc,KAAK,GAAG,CAAC,KAAK;AAAA,EACrF;AAEA,SAAO;AACT;AAEA,SAAS,gBACP,EAAE,UAAU,SAAS,CAAC,GAAG,oBAAoB,KAAK,GAClD,KACA,YACA;AACA,QAAM,gBAA0B,CAAC;AACjC,QAAM,iBAA2B,OAAO,IAAI,OAAK,iBAAiB,GAAG,mBAAmB,KAAK,YAAY,IAAI,CAAC;AAE9G,MAAI,CAAC,UAAU;AACb,WAAO,EAAE,OAAO,CAAC,MAAM,GAAG,QAAQ,eAAe;AAAA,EACnD;AAEA,WAAS,WAAW,UAAU;AAC5B,cAAU,iBAAiB,SAAS,mBAAmB,KAAK,YAAY,KAAK;AAC7E,QAAI,QAAQ,WAAW,GAAG,KAAK,QAAQ,CAAC,MAAM,KAAK;AACjD,qBAAe,KAAK,QAAQ,MAAM,CAAC,CAAC;AAAA,IACtC,OAAO;AACL,oBAAc,KAAK,OAAO;AAAA,IAC5B;AAAA,EACF;AAEA,SAAO,EAAE,OAAO,eAAe,QAAQ,eAAe;AACxD;AAGA,SAAS,gBAAgBA,OAAc,KAAa,MAAc;AAChE,SAAO,MAAM,SAAS,KAAK,GAAG,IAAI,IAAIA,KAAI,EAAE;AAC9C;AAEA,SAAS,YAAYA,OAAc,KAAa,MAAc,aAAsB,UAAoB;AACtG,QAAM,eAAe,WAAWA,MAAK,MAAM,KAAK,SAAS,CAAC,IAAIA;AAE9D,MAAI,SAAS,KAAK;AAChB,WAAO,cAAc,aAAa,MAAM,GAAG,EAAE,IAAI;AAAA,EACnD;AAEA,SAAO,gBAAgB,cAAc,KAAK,IAAI;AAChD;AAIA,SAAS,MAAM,SAAsB,KAAa,MAAe;AAC/D,QAAM,aAAa;AAAA,IACjB,MAAM;AAAA,IACN,YAAY;AAAA,IACZ,aAAa;AAAA,EACf;AAEA,QAAM,YAAY,gBAAgB,SAAS,KAAK,UAAU;AAE1D,QAAM,UAAU,UAAU,UAAU,OAAO;AAAA,IACzC,KAAK,QAAQ;AAAA,IACb,QAAQ,UAAU;AAAA,EACpB,CAAC;AAED,QAAM,UAAU,UAAU,UAAU,QAAQ;AAAA,IAC1C,KAAK,QAAQ;AAAA,EACf,CAAC;AAED,QAAM,cAAoC;AAAA;AAAA,IAExC,SAAS,CAAC,CAAC,GAAG,gBAAgB,QAAQ,YAAY,GAAG,KAAK,WAAW,MAAM,aAAa,QAAQ,QAAQ,CAAC,CAAC;AAAA,IAC1G,SAAS,CAAC,GAAG,MAAM,QAAQ,YAAY,GAAG,KAAK,WAAW,MAAM,MAAM,IAAI,CAAC;AAAA,IAC3E,eAAe;AAAA,IACf,eAAe;AAAA,EACjB;AAEA,MAAI,QAAQ,MAAM;AAChB,gBAAY,WAAW,KAAK,MAAM,QAAQ,OAAO,WAAW,WAAW;AAAA,EACzE;AAEA,MAAI,QAAQ,UAAU;AACpB,gBAAY,gBAAgB;AAC5B,gBAAY,eAAe;AAC3B,gBAAY,kBAAkB;AAAA,EAChC;AAEA,MAAI,QAAQ,iBAAiB;AAC3B,gBAAY,eAAe;AAC3B,gBAAY,cAAc;AAAA,EAC5B,WAAW,QAAQ,cAAc,OAAO;AACtC,gBAAY,cAAc;AAAA,EAC5B;AAEA,QAAM,MAAM,IAAI,KAAK,WAAW,EAAE,MAAM,WAAW,IAAI;AAEvD,MAAI,QAAQ,WAAW,QAAQ,QAAQ,UAAU;AAC/C,WAAO,OAAO,IAAI,KAAK,IAAI,IAAI,YAAY;AAAA,EAC7C;AAEA,SAAO,OACH,IAAI,KAAK,EAAE,IAAI,OAAK,gBAAgB,GAAG,KAAK,WAAW,IAAI,KAAK,CAAC,KAAK,EAAE,SAAS,GAAG,IAAI,MAAM,GAAG,IACjG,IACG,YAAY,EACZ,KAAK,WAAS,MAAM,IAAI,OAAK,gBAAgB,GAAG,KAAK,WAAW,IAAI,KAAK,CAAC,KAAK,EAAE,SAAS,GAAG,IAAI,MAAM,GAAG,CAAC;AACpH;AAIA,eAAsB,KAAK,mBAA2C,SAA0C;AAC9G,MAAI,sBAAqB,mCAAS,WAAU;AAC1C,UAAM,IAAI,MAAM,wDAAwD;AAAA,EAC1E;AAEA,QAAM,OAAO,MAAM,QAAQ,iBAAiB,IAAI,EAAE,GAAG,SAAS,UAAU,kBAAkB,IAAI;AAC9F,QAAM,MAAM,KAAK,MAAM,KAAK,QAAQ,KAAK,GAAG,EAAE,QAAQ,OAAO,GAAG,IAAI,QAAQ,IAAI,EAAE,QAAQ,OAAO,GAAG;AAEpG,SAAO,MAAM,MAAM,KAAK,KAAK;AAC/B;AAIO,SAAS,SAAS,mBAA2C,SAAiC;AACnG,MAAI,sBAAqB,mCAAS,WAAU;AAC1C,UAAM,IAAI,MAAM,wDAAwD;AAAA,EAC1E;AAEA,QAAM,OAAO,MAAM,QAAQ,iBAAiB,IAAI,EAAE,GAAG,SAAS,UAAU,kBAAkB,IAAI;AAC9F,QAAM,MAAM,KAAK,MAAM,KAAK,QAAQ,KAAK,GAAG,EAAE,QAAQ,OAAO,GAAG,IAAI,QAAQ,IAAI,EAAE,QAAQ,OAAO,GAAG;AAEpG,SAAO,MAAM,MAAM,KAAK,IAAI;AAC9B;","names":["path"]}